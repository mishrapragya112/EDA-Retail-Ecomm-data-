
#getting all the required libraries and datasets

import plotly.graph_objs as go
import plotly.io as pio
pio.renderers.default = "plotly_mimetype+notebook"
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from completejourney_py import get_data
import pandas as pd
# get_data() provides a dictionary of several DataFrames
cj_data = get_data()
cj_data.keys()
tables_data = get_data()
# Now you can access the tables inside the returned data
transactions = tables_data['transactions']
demographics = tables_data['demographics']
campaign_descriptions = tables_data['campaign_descriptions']
coupons = tables_data['coupons']
promotions = tables_data['promotions']
campaigns = tables_data['campaigns']
coupon_redemptions = tables_data['coupon_redemptions']
products = tables_data['products']

# Merge transactions and demographics data
merged_df = pd.merge(transactions, products, how='inner')
#print("Number of transactions with prods information:", transactions_with_demographic_info)
transactions_products_demo_info = pd.merge(merged_df, demographics, how='inner')


# ### Data Preparation 

# In[2]:


def income_class(row):
    if row['income'] in ('Under 15K','15-24K','25-34K','35-49K'):
        return 'Low Income'
    elif row['income'] in ('50-74K','75-99K','100-124K','125-149K'):
        return 'Mid Income' 
    elif row['income'] in ('150-174K','175-199K','200-249K','250K+'):
        return 'High Income' 
    else:
        return 'Unknown'

transactions_products_demo_info['income_class'] = transactions_products_demo_info.apply(income_class, axis=1)
grouped_data = transactions_products_demo_info.groupby(['income_class', 'product_type'])['sales_value'].sum().reset_index()


# ###  Consumer Purchasing behavior over time
# 

# In[3]:


#transactions_products_demo_info['transaction_timestamp'] = pd.to_datetime(transactions_products_demo_info['transaction_timestamp'])
#transactions_products_demo_info.set_index('transaction_timestamp', inplace=True)
weekly_sales = transactions_products_demo_info.groupby('week').agg({'sales_value': 'sum', 'quantity': 'sum'})
fig, ax1 = plt.subplots(figsize=(12, 6))
sns.lineplot(x=weekly_sales.index, y=weekly_sales['sales_value'], color='b', marker='o', label='Weekly Sales', ax=ax1)
ax1.set_xlabel('Week', fontsize=14)
ax1.set_ylabel('Sales', color='b', fontsize=14)
ax1.tick_params('y', colors='b')
ax2 = ax1.twinx()
sns.lineplot(x=weekly_sales.index, y=weekly_sales['quantity'], color='g', marker='o', label='Weekly Quantity', ax=ax2)
ax2.set_ylabel('Quantity', color='g', fontsize=14)
ax2.tick_params('y', colors='g')
plt.title('Purchasing behavior over time', fontsize=16)

plt.grid(True, linestyle='--', alpha=0.7)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()


# ## To comprehend customer purchasing behaviors, I conducted a comprehensive analysis of the complete_journey dataset on two key dimensions:
# 
# ##### Income Class Analysis: 
# Examining consumer income classes to uncover distinct buying patterns across various product categories.
# ##### Household Size Analysis: 
# Investigating household sizes to discern buying patterns associated with different products.
# 
# #### Following these comprehensive analyses, I delved into evaluating the effectiveness of existing $\color{red}{\text{promotions}}$ for both products and departments. This exploration aimed to identify opportunities for optimizing $\color{red}{\text{Regork's}}$ promotion and campaign strategies to maximize sales.

# ## Income class analysis: 

# In the initial stages of data preparation, we introduced the "income class" variable as a foundation for this analysis.
# 
# We aim to identify within the entire demographic spectrum, specifically based on income, which groups are contributing significantly to the revenue generated by top products.

# In[4]:


#Get the top 5 product_type in each income_class
top_prod_categories = grouped_data.groupby('income_class').apply(lambda x: x.nlargest(5, 'sales_value')).reset_index(drop=True).sort_values(by=['sales_value'], ascending=[True])
import plotly.express as px
fig = px.treemap(top_prod_categories, path=['income_class', 'product_type'], values='sales_value',
                 title='Top 5 Product Types by Income Class')
fig.update_layout(template='plotly_dark')
fig.show()


# ### "Gasoline, Fluid Milk, Soft Drinks and Beer/Ale/Malt Liquors" products demonstrated equal prominence across all income classes (Mid Income, Low Income, High Income) in terms of the sales value they generated.

# # Lets check did the current promotions help in their sales?

# In[5]:


# Current promotions of products 
merged_df = pd.merge(transactions, products, how='inner')
#transactions_with_products_info = merged_df.shape[0]
transactions_products_promo_info = pd.merge(merged_df, promotions, how='inner')
grouped_data_promo = transactions_products_promo_info.groupby(['product_type','display_location'])['sales_value'].sum().reset_index()
# Get the top 5 product_type in each income_class
top_prods_categories = grouped_data_promo.groupby('display_location').apply(lambda x: x.nlargest(2, 'sales_value')).reset_index(drop=True).sort_values(by=['sales_value'], ascending=[False])
df = pd.DataFrame(top_prods_categories)
fig = px.bar(df, x='product_type', y='sales_value', color='display_location',
             title='Promotions vs sales',
             labels={'sales_value': 'Sales Value', 'product_type': 'Product Type', 'display_location': 'Display Location'},
             hover_data=['display_location'])
fig.update_layout(template='plotly_dark')
fig.update_layout(barmode='stack')
fig.show()


# ### Based on the preceding analysis, it can be inferred that promotions for the top products were strategically executed across different display locations, boosting their sales.
# ### Notably, for Fluid Milk, Soft Drinks, and Beer/Ale/Malt Liquors, display locations (0-Display) and (3-Front End Cap) emerged as particularly influential.

# ##### Based on our analysis of income class, lets check what products actually need revived promotional strategies?

# In[6]:


grouped_data = transactions_products_demo_info.groupby(['income_class', 'product_type'])['sales_value'].sum().reset_index()
filtered_data = grouped_data[grouped_data['sales_value'] > 0]
# Get the top 5 product types in each income class
low_prod_categories = (filtered_data
                       .groupby('income_class')
                       .apply(lambda x: x.nsmallest(5, 'sales_value'))
                       .reset_index(drop=True)).sort_values(by=['sales_value'], ascending=[True])
fig = px.treemap(low_prod_categories, path=['income_class', 'product_type'], values='sales_value',
                 title='Least sold product types by Income Class')
fig.update_layout(template='plotly_dark')
fig.show()


# ### Enhanced marketing efforts are recommended for specific products within each income class:
# 
# ##### High Income Class: 
# Strengthen promotions for Pasta Rice Beans, Frozen Food, and Carbonated Beverages.
# 
# ##### Low Income Class: 
# Focus on marketing School Instruments, Travel Aids, and Non-food Kosher items.
# 
# ##### Mid Income Class: 
# Elevate promotional strategies for Ethnic HBC (Health and Beauty Care) Items and Non-food Kosher items.

# ## Lets check did the product size affect the sales and revenue?

# In[7]:


#package size sold by quantity
grouped_data = transactions_products_demo_info.groupby(['income_class', 'package_size'])['quantity'].sum().reset_index()
# Get the top product_type in each income_class
top_package_size = grouped_data.groupby('income_class').apply(lambda x: x.nlargest(5, 'quantity')).reset_index(drop=True).sort_values(by=['quantity'], ascending=[True])
fig = px.bar(top_package_size, x='income_class', y='quantity', color='package_size',
             title='Top 5 Package Sizes by Income Class',
             labels={'quantity': 'Quantity', 'income_class': 'Income Class', 'package_size': 'Package Size'})
fig.update_layout(template='plotly_dark')
fig.update_layout(barmode='group')
fig.show()


# In[8]:


#package size sold by quantity
grouped_data = transactions_products_demo_info.groupby(['income_class', 'package_size'])['quantity'].sum().reset_index()
filtered_data = grouped_data[grouped_data['quantity'] > 0]
# Get the top product_type in each income_class
lowestquant_package_size = filtered_data.groupby('income_class').apply(lambda x: x.nsmallest(5, 'quantity')).reset_index(drop=True).sort_values(by=['quantity'], ascending=[True])
fig = px.bar(lowestquant_package_size, x='income_class', y='quantity', color='package_size',
             title='Least sold package Sizes by Income Class',
             labels={'quantity': 'Quantity', 'income_class': 'Income Class', 'package_size': 'Package Size'})
fig.update_layout(template='plotly_dark')
fig.update_layout(barmode='group')
fig.show()


# ### Mid-Package size of 16 oz and 12 oz dominated the market with highest sales, whereas package of very small and very large size i.e. 2LB, 0.07 oz were not sold

# ## Household Size Analysis: 

# ##### Let's examine the sales and quantity sold metrics across different household size levels.

# ### Sales contribution by household size

# In[9]:


# calculating the total sales value for each category
agg_df = transactions_products_demo_info.groupby(['household_size','department', 'product_category','product_type','quantity','marital_status','income'])['sales_value'].sum().reset_index()
#agg_df
#Finding the top 5 product categories based on total sales value
top_categories = agg_df.groupby('department')['sales_value'].sum().nlargest(5).index
agg_df_top5_dept = agg_df[agg_df['department'].isin(top_categories)]
#agg_df_top5_dept
#top_categories
top_dept_products = agg_df_top5_dept.groupby('product_category')['sales_value'].sum().nlargest(10).index
#top_dept_products
agg_df_top5_prods = agg_df_top5_dept[agg_df_top5_dept['product_category'].isin(top_dept_products)]
agg_df_top5_prods
df = agg_df_top5_prods
fig = px.sunburst(df, path=['household_size'], values='sales_value', color='household_size',
                 title=f'Sales contribution by household size')
fig.update_layout(
    plot_bgcolor='black', 
    paper_bgcolor='black',  
    font=dict(color='white'),  
    sunburstcolorway=['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A'],  # Set custom colors
)
fig.show()
df = agg_df_top5_prods
fig = px.sunburst(df, path=['household_size'], values='quantity', color='household_size',
                 title=f'Quantity contribution by household size')
fig.update_layout(
    plot_bgcolor='black', 
    paper_bgcolor='black',
    font=dict(color='white'),
    sunburstcolorway=['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A'],
)

fig.show()


# ### Top performing departments and product categories in each household type

# In[10]:


unique_sizes = agg_df_top5_prods['household_size'].unique()
fig_list = []
template_name = "plotly_dark"
for size_value in unique_sizes:
    subset_df = agg_df_top5_prods[agg_df_top5_prods['household_size'] == size_value]
    fig = px.sunburst(subset_df, path=['department', 'product_category'], values='sales_value', color='department',
                      title=f'Top performing departments and product categories for Household Size {size_value}', template=template_name)
    fig_list.append(fig)
for fig in fig_list:
    fig.show()


# ### Based on the analysis, it is evident that households with 1 and 2 members significantly contributed to Regork's sales. The top-performing departments and product categories within each household size were predominantly Grocery, Fuel, Meat, and their respective products.

# ### When we see the promotions, we realise these are also strategically the most promoted departments : 
# #### "Grocery, Meat, Produce" as shown below

# In[11]:


# Merge transactions and demographics data
merged_df = pd.merge(transactions, products, how='inner')
#transactions_with_products_info = merged_df.shape[0]
transactions_products_promo_info = pd.merge(merged_df, promotions, how='inner')
grouped_data_promo = transactions_products_promo_info.groupby(['department', 'display_location'])['sales_value'].sum().reset_index()
top_dept_categories = grouped_data_promo.groupby('department').apply(lambda x: x.nlargest(5, 'sales_value')).reset_index(drop=True).sort_values(by=['sales_value'], ascending=[False])
df = pd.DataFrame(top_dept_categories)
fig = px.bar(df, x='sales_value', y='department', color='display_location',
             title='Sales by Department and their promotions',
             labels={'sales_value': 'Sales', 'department': 'Department', 'sales_value': 'Sales Value'})
fig.update_layout(template='plotly_dark')
fig.show()


# # Summary in brief:
# Weekly analysis showed trends in both sales and quantity, providing insights into purchasing behavior over time.
# 
# ### Income Class Analysis:
# Gasoline, Fluid Milk, Soft Drinks, and Beer/Ale/Malt Liquors were top-performing products across all income classes.
# Promotions for these products were strategically executed at display locations (0-Display) and (3-Front End Cap).
# Enhanced marketing efforts are recommended for specific products within each income class: Pasta Rice Beans, Frozen Food, Carbonated Beverages (High Income Class); School Instruments, Travel Aids, Non-food Kosher items (Low Income Class); 
# Ethnic HBC Items, Non-food Kosher items (Mid Income Class).
# 
# ### Promotional Effectiveness:
# Promotions for top products significantly influenced sales, especially at display locations (0-Display) and (3-Front End Cap).
# 
# ### Product Size Impact:
# Mid-sized packages (16 oz and 12 oz) dominated sales, while very small and very large sizes (2LB, 0.07 oz) had minimal sales.
# 
# ### Household Size Analysis:
# Households with 1 and 2 members made substantial contributions to Regork's sales.
# Top-performing departments and product categories for each household size were Grocery, Fuel, Meat, and related products.
# Promotions aligned with the most promoted departments: Grocery, Meat, Produce.

# # Recommendations:
#     
# ### Product-Specific Marketing:
# Launch targeted advertising campaigns for Pasta Rice Beans, Frozen Food, and Carbonated Beverages towards the High Income Class.
# Implement cost-effective promotional strategies for School Instruments, Travel Aids, and Non-food Kosher items, catering to the Low Income Class.
# Develop promotional content highlighting Ethnic HBC Items and Non-food Kosher items for the Mid Income Class.
# 
# ### Promotion Placement:
# Evaluate the success of promotions at display locations (0-Display) and (3-Front End Cap) for Fluid Milk, Soft Drinks, and Beer/Ale/Malt Liquors.
# Consider experimenting with different display locations to optimize visibility and impact.
# 
# ### Package Size Strategy:
# Conduct consumer surveys or feedback sessions to understand preferences for package sizes.
# Introduce limited-time promotions or discounts on mid-sized packages (16 oz and 12 oz) to encourage their purchase.
# 
# ### Targeted Marketing for Household Sizes:
# Design marketing materials and promotions specifically tailored to the needs of single-member and two-member households.
# Consider loyalty programs or exclusive offers to incentivize repeat purchases from these household sizes.
# 
# ### Department-Specific Promotions:
# Diversify promotions within the Grocery, Meat, and Produce departments to showcase a wider range of products.
# Collaborate with suppliers or introduce exclusive deals on specific products within these departments.
# 
# ### Overall Evaluate Promotion Effectiveness:
# Implement a system to track the impact of promotions on sales, considering factors like display location, timing, and product type.
# Analyze customer feedback and purchasing patterns to continuously refine and optimize promotion strategies.
# Collaborative Marketing Campaigns:
# 
# ##### By implementing these specific recommendations, Regork can fine-tune its strategies to resonate with different consumer segments, enhance promotional effectiveness, and ultimately drive sustainable growth in sales.
